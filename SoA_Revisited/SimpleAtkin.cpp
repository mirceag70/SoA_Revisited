#include "Helper.h"

//naive
tpPrime SoA0(const tpPrime limit, bool sieve[], void*, void*)
{
	for (tpPrime i = 0; i < limit; i++) sieve[i] = false;
	// 2 and 3 are not generated by the alghorithm
	sieve[2] = true; sieve[3] = true;

	// main loop - remove quadratic forms 
	for (tpPrime x = 1; x * x < limit; x++)
		for (tpPrime y = 1; y * y < limit; y++)
		{
			tpPrime n = (4 * x * x) + (y * y);
			if (n <= limit && (n % 12 == 1 || n % 12 == 5))
				sieve[n] ^= true;

			n = (3 * x * x) + (y * y);
			if (n <= limit && n % 12 == 7)
				sieve[n] ^= true;

			n = (3 * x * x) - (y * y);
			if (x > y && n <= limit && n % 12 == 11)
				sieve[n] ^= true;
		}

	// secondary loop - remove multiple of squares
	for (tpPrime i = 5; i * i < limit; i++) 
		if (sieve[i])
			for (tpPrime j = i * i; j < limit; j += i * i)
				sieve[j] = false;

	tpPrime numprimes = 0;
	// last loop - get primes
	for (tpPrime i = 1; i < limit; i++)
		if (sieve[i]) { numprimes++; AddPrime(i); }
	return numprimes;
}

//standard
tpPrime SoA1(const tpPrime limit, bool sieve[], void*, void*)
{
	for (tpPrime i = 0; i < limit; i++) sieve[i] = false;
	// 2 and 3 are not generated by the alghorithm
	tpPrime i, numprimes = 2; sieve[2] = true; sieve[3] = true;
	AddPrime(2); AddPrime(3);

	for (tpPrime x = 1; 4 * x * x < limit; x++)
		for (tpPrime y = 1; ; y++)
		{
			tpPrime n = (4 * x * x) + (y * y);
			if (n > limit) break;
			if (n % 12 == 1 || n % 12 == 5) sieve[n] ^= true;
		}

	for (tpPrime x = 1; 3 * x * x < limit; x++)
		for (tpPrime y = 1; ; y++)
		{
			tpPrime n = (3 * x * x) + (y * y);
			if (n > limit) break;
			if (n % 12 == 7) sieve[n] ^= true;
		}

	for (tpPrime x = 1; 2 * x * x < limit; x++)
		for (tpPrime y = 1; y < x; y++)
		{
			tpPrime n = (3 * x * x) - (y * y);
			if (n <= limit && n % 12 == 11) sieve[n] ^= true;
		}

	auto Loop1 = [&](tpPrime i)
	{
		if (sieve[i])
		{
			numprimes++; AddPrime(i);
			for (tpPrime j = i * i; j < limit; j += 2 * i * i)
				sieve[j] = false;
		}
	};

	// secondary loop - remove multiple of squares
	for (i = 6; i * i < limit; i += 6)
		{ Loop1(i - 1); Loop1(i + 1); }

	auto Loop2 = [&](tpPrime i)
	{
		if (sieve[i]) { numprimes++; AddPrime(i); }
	};

	// last loop - get primes
	for (; i < limit; i += 6)
		{ Loop2(i - 1); Loop2(i + 1); }
	return numprimes;
}

//1bit, 6k +/- 1
tpPrime SoA2(const tpPrime limit, uint8_t sieve[], void*, void*)
{
	auto SetBit = [&](tpPrime n)
	{
		tpPrime bitidx = no2idx(n);
		tpPrime idx = bitidx / 8, bit = (uint8_t)(bitidx % 8);
		sieve[idx] |= BIT_MASK[bit];
	};
	auto GetBit = [&](tpPrime n)
	{
		tpPrime bitidx = no2idx(n);
		uint64_t idx = bitidx / 8, bit = (uint8_t)(bitidx % 8);
		return (sieve[idx] & BIT_MASK[bit]);
	};
	auto ResetBit = [&](tpPrime n)
	{
		tpPrime bitidx = no2idx(n);
		uint64_t idx = bitidx / 8, bit = (uint8_t)(bitidx % 8);
		sieve[idx] &= BIT_RESET_MASK[bit];
	};
	auto FlipBit = [&](tpPrime n)
	{
		tpPrime bitidx = no2idx(n);
		uint64_t idx = bitidx / 8, bit = (uint8_t)(bitidx % 8);
		sieve[idx] ^= BIT_MASK[bit];
	};

	// 2 and 3 are not generated by the alghorithm
	tpPrime i, n, x, y, numprimes = 2; AddPrime(2); AddPrime(3);
	for (i = 0; i <= limit/24; i++) sieve[i] = false;

	for (x = 1; 4 * x * x < limit; x++)
		for (y = 1; ; y++)
		{
			n = (4 * x * x) + (y * y);
			if (n > limit) break;
			if (n % 12 == 1 || n % 12 == 5) 
				FlipBit(n);
		}

	for (x = 1; 3 * x * x < limit; x++)
		for (y = 1; ; y++)
		{
			n = (3 * x * x) + (y * y);
			if (n > limit) break;
			if (n % 12 == 7) 
				FlipBit(n);
		}

	for (x = 1; 2 * x * x < limit; x++)
		for (y = 1; y < x; y++)
		{
			n = (3 * x * x) - (y * y);
			if (n <= limit && n % 12 == 11) 
				FlipBit(n);
		}

	auto Loop1 = [&](tpPrime i)
	{
		if (GetBit(i))
		{
			int step = 2;
			numprimes++; AddPrime(i);
			for (tpPrime j = i * i; j < limit; j += step * i * i)
			{
				ResetBit(j);
				step = 6 - step;
			}
		}
	};

	// secondary loop - remove multiple of squares
	for (i = 6; i * i < limit; i += 6)
		{ Loop1(i - 1); Loop1(i + 1); }

	auto Loop2 = [&](tpPrime i)
	{ if (GetBit(i)) { numprimes++; AddPrime(i); } };

	// last loop - get primes
	for (; i < limit; i += 6)
		{ Loop2(i - 1); Loop2(i + 1); }
	return numprimes;
}

//tinkering - no value here
tpPrime SoA3(const tpPrime limit, uint8_t sieve[], void*, void*)
{
	auto SetBit   = [&](tpPrime n)
	{
		tpPrime bitidx = no2idx(n);
		tpPrime idx = bitidx / 8, bit = (uint8_t)(bitidx % 8);
		sieve[idx] |= BIT_MASK[bit];
	};
	auto GetBit   = [&](tpPrime n)
	{
		tpPrime bitidx = no2idx(n);
		uint64_t idx = bitidx / 8, bit = (uint8_t)(bitidx % 8);
		return (sieve[idx] & BIT_MASK[bit]);
	};
	auto ResetBit = [&](tpPrime n)
	{
		tpPrime bitidx = no2idx(n);
		uint64_t idx = bitidx / 8, bit = (uint8_t)(bitidx % 8);
		sieve[idx] &= BIT_RESET_MASK[bit];
	};
	auto FlipBit  = [&](tpPrime n)
	{
		tpPrime bitidx = no2idx(n);
		uint64_t idx = bitidx / 8, bit = (uint8_t)(bitidx % 8);
		sieve[idx] ^= BIT_MASK[bit];
	};

	// 2 and 3 are not generated by the alghorithm
	tpPrime i, n, x, y, numprimes = 2; AddPrime(2); AddPrime(3);
	for (i = 0; i <= limit / 24; i++) sieve[i] = false;

	for (x = 1; x * x < (limit/4); x++)
		for (y = 1; ; y++)
		{
			n = (4 * x * x) + (y * y);
			if (n > limit) break;
			if (n % 12 == 1 || n % 12 == 5)
				FlipBit(n);
		}

	for (x = 1; x * x < (limit/3); x++)
		for (y = 1; ; y++)
		{
			n = (3 * x * x) + (y * y);
			if (n > limit) break;
			if (n % 12 == 7)
				FlipBit(n);
		}

	for (x = 1; x * x < (limit/2); x++)
		for (y = 1; y < x; y++)
		{
			n = (3 * x * x) - (y * y);
			if (n <= limit && n % 12 == 11)
				FlipBit(n);
		}

	auto Loop1 = [&](tpPrime i)
	{
		if (GetBit(i))
		{
			int step = 2;
			numprimes++; AddPrime(i);
			for (tpPrime j = i * i; j < limit; j += step * i * i)
			{
				ResetBit(j);
				step = 6 - step;
			}
		}
	};

	// secondary loop - remove multiple of squares
	for (i = 6; i * i < limit; i += 6)
	{
		Loop1(i - 1); Loop1(i + 1);
	}

	auto Loop2 = [&](tpPrime i)
	{ if (GetBit(i)) { numprimes++; AddPrime(i); } };

	// last loop - get primes
	for (; i < limit; i += 6)
	{
		Loop2(i - 1); Loop2(i + 1);
	}
	return numprimes;
}

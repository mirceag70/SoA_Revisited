#include "Helper.h"

//incremental
tpPrime SoA_I(const tpPrime limit, uint8_t sv[], void*, void*)
{
	const tpPrime svlen = (limit / 96) + 2;
	uint8_t* sieve1 = sv;			  uint8_t* sieve5 = sieve1 + svlen;
	uint8_t* sieve7 = sieve5 + svlen; uint8_t* sieve11 = sieve7 + svlen;

	auto GetBit = [&](tpPrime n, uint8_t sieve[])
	{
		tpPrime q = (n / 12) / 8, r = (n / 12) % 8;
		return (sieve[q] & BIT_MASK[r]);
	};
	auto ResetBit = [&](tpPrime n, uint8_t sieve[])
	{
		tpPrime q = (n / 12) / 8, r = (n / 12) % 8;
		sieve[q] &= BIT_RESET_MASK[r];
	};
	auto FlipBit = [&](tpPrime n, uint8_t sieve[])
	{
		tpPrime q = (n / 12) / 8, r = (n / 12) % 8;
		sieve[q] ^= BIT_MASK[r];
	};


	// 2 and 3 are not generated by the alghorithm
	tpPrime i, numprimes = 2; AddPrime(2); AddPrime(3);
	for (i = 0; i < 4 * svlen; i++) sv[i] = false;

	auto Sieve = [&]<typename FN>(FN fn1)
	{
		tpPrime iter_min = 0;
		if (limit > STEP_SIZE)
			for (; iter_min < (limit - STEP_SIZE); iter_min += STEP_SIZE)
				fn1(iter_min, iter_min + STEP_SIZE);
		fn1(iter_min, limit);
	};

	cTimer tmr;
	tmr.Start();

	//1 mod 12
	auto Pattern11 = [&](const tpPrime start, const tpPrime stop)
	{
		const tpPrime xmax = (tpPrime)floor(sqrt(stop / 4));
		for (tpPrime x = 1, jmp = 0; x <= xmax; x += (1 + jmp), jmp = 1 - jmp)
		{
			//get in position
			tpPrime y, n0 = 4 * x * x;
			if (n0 < start)
			{
				const tpPrime yy = (tpPrime)ceil(sqrt(start - n0));
				y = 6 * (yy / 6) + 3;
				if (y < yy) y += 6;
			}
			else y = 3;
			//sieve
			for (; ; y += 6)
			{
				tpPrime n = n0 + (y * y);
				if (n > stop) break;
				FlipBit(n, sieve1);
			}
		}
	};
	Sieve(Pattern11);
	tmr.LapTime(true, "ptrn11");
	//goto ENDS;

	auto Pattern12 = [&](const tpPrime start, const tpPrime stop)
	{
		//for x = 0 we can not start with y = 1
		uint8_t step = 2;
		const tpPrime yy = (tpPrime)ceil(sqrt(start));
		tpPrime y = 6 * (yy / 6) + 5;
		if (y < yy)
		{
			y += 2;
			if (y < yy) y += 4;
			else step = 4;
		}
		for (; ; y += step, step = 6 - step)
		{
			tpPrime n = y * y;
			if (n > limit) break;
			FlipBit(n, sieve1);
		}
		const tpPrime xmax = (tpPrime)floor(sqrt(limit / 4));
		for (tpPrime x = 3; x <= xmax; x += 3)
		{
			//get in position
			uint8_t step = 4;
			tpPrime y, n0 = 4 * x * x;
			if (n0 < start)
			{
				const tpPrime yy = (tpPrime)ceil(sqrt(start - n0));
				y = 6 * (yy / 6) + 1;
				if (y < yy)
				{
					y += 4;
					if (y < yy) y += 2;
					else step = 2;
				}
			}
			else y = 1;
			//sieve
			for (; ; y += step, step = 6 - step)
			{
				tpPrime n = (4 * x * x) + (y * y);
				if (n > stop) break;
				FlipBit(n, sieve1);
			}
		}
	};
	Sieve(Pattern12);
	tmr.LapTime(true, "ptrn12");

	//5 mod 12
	auto Pattern5 = [&](const tpPrime start, const tpPrime stop)
	{
		const tpPrime xmax = (tpPrime)floor(sqrt(stop / 4));
		for (tpPrime x = 1, jmp = 0; x <= xmax; x += 1 + jmp, jmp = 1 - jmp)
		{
			//get in position
			uint8_t step = 4;
			tpPrime y, n0 = 4 * x * x;
			if (n0 < start)
			{
				const tpPrime yy = (tpPrime)ceil(sqrt(start - n0));
				y = 6 * (yy / 6) + 1;
				if (y < yy)
				{
					y += 4;
					if (y < yy) y += 2;
					else step = 2;
				}
			}
			else y = 1;
			//sieve
			for (; ; y += step, step = 6 - step)
			{
				tpPrime n = n0 + (y * y);
				if (n > stop) break;
				FlipBit(n, sieve5);
			}
		}
	};
	Sieve(Pattern5);
	tmr.LapTime(true, "ptrn5");

	//7 mod 12
	auto Pattern7 = [&](const tpPrime start, const tpPrime stop)
	{
		const tpPrime xmax = (tpPrime)floor(sqrt(stop / 3));
		for (tpPrime x = 1; x <= xmax; x += 2)
		{
			//get in position
			uint8_t step = 2;
			tpPrime y, n0 = 3 * x * x;
			if (n0 < start)
			{
				const tpPrime yy = (tpPrime)ceil(sqrt(start - n0));
				y = 6 * (yy / 6) + 2;
				if (y < yy)
				{
					y += 2;
					if (y < yy) y += 4;
					else step = 4;
				}
			}
			else y = 2;
			//sieve			
			for (; ; y += step, step = 6 - step)
			{
				tpPrime n = n0 + (y * y);
				if (n > stop) break;
				FlipBit(n, sieve7);
			}
		}
	};
	Sieve(Pattern7);
	tmr.LapTime(true, "ptrn7");

	//11 mod 12
	auto Pattern111 = [&](const tpPrime start, const tpPrime stop)
	{
		const tpPrime xmax = (tpPrime)floor(sqrt(stop / 2));
		tpPrime x = (tpPrime)ceil(sqrt(start / 3));
		if (x & 1) x++;
		for (; x <= xmax; x += 2)
		{
			//get in position
			uint8_t step = 4;
			tpPrime y, n0 = 3 * x * x;
			if (n0 > stop)
			{
				const tpPrime yy = (tpPrime)ceil(sqrt(n0 - stop));
				y = 6 * (yy / 6) + 1;
				if (y < yy)
				{
					y += 4;
					if (y < yy) y += 2;
					else step = 2;
				}
			}
			else y = 1;
			//sieve			
			for (; x > y; y += step, step = 6 - step)
			{
				tpPrime n = n0 - (y * y);
				if (n < start) break;
				FlipBit(n, sieve11);
			}
		}
	};
	Sieve(Pattern111);
	tmr.LapTime(true, "ptrn111");

	auto Pattern112 = [&](const tpPrime start, const tpPrime stop)
	{
		const tpPrime xmax = (tpPrime)floor(sqrt(stop / 2));
		tpPrime x = (tpPrime)ceil(sqrt(start / 3));
		if (not (x & 1)) x++;
		for (; x <= xmax; x += 2)
		{
			//get in position
			uint8_t step = 2;
			tpPrime y, n0 = 3 * x * x;
			if (n0 > stop)
			{
				const tpPrime yy = (tpPrime)ceil(sqrt(n0 - stop));
				y = 6 * (yy / 6) + 2;
				if (y < yy)
				{
					y += 2;
					if (y < yy) y += 4;
					else step = 4;
				}
			}
			else y = 2;
			//sieve			
			for (; x > y; y += step, step = 6 - step)
			{
				tpPrime n = n0 - (y * y);
				if (n < start) break;
				FlipBit(n, sieve11);
			}
		}
	};
	Sieve(Pattern112);

	tmr.LapTime(true, "ptrn112");

	// secondary loop - remove multiple of squares
	auto MarkSquares = [&](uint8_t work_sieve[], const unsigned rem)
	{
		auto MarkOneSquare = [&](uint8_t sieve[], const tpPrime n)
		{
			if (GetBit(n, sieve))
				for (tpPrime i = rem * n * n; i < limit; i += 12 * n * n)
					ResetBit(i, work_sieve);
		};

		MarkOneSquare(sieve5, 5);
		MarkOneSquare(sieve7, 7);
		MarkOneSquare(sieve11, 11);
		for (tpPrime k = 12; k < sqrt(limit); k += 12)
		{
			MarkOneSquare(sieve1, k + 1);
			MarkOneSquare(sieve5, k + 5);
			MarkOneSquare(sieve7, k + 7);
			MarkOneSquare(sieve11, k + 11);
		}
	};
	MarkSquares(sieve1, 1); MarkSquares(sieve5, 5);
	MarkSquares(sieve7, 7); MarkSquares(sieve11, 11);
	tmr.LapTime(true, "squares");

	// last loop - get primes
	auto CountOnePrime = [&](const tpPrime n)
	{ /*if (n < limit)*/ { numprimes++; AddPrime(n); } };
	for (tpPrime k = 0; k < svlen; k++)
	{
		uint8_t sv1 = sieve1[k], sv5 = sieve5[k], sv7 = sieve7[k], sv11 = sieve11[k];
		for (unsigned b = 0; b < 8; b++)
		{
			tpPrime n = 12 * (8 * k + b);
			if (sv1 & BIT_MASK[b]) CountOnePrime(n + 1);
			if (sv5 & BIT_MASK[b]) CountOnePrime(n + 5);
			if (sv7 & BIT_MASK[b]) CountOnePrime(n + 7);
			if (sv11 & BIT_MASK[b]) CountOnePrime(n + 11);
		}
	}

	tmr.LapTime(true, "counting");
	tmr.Stop(/*true, "squares & counting"*/);
	return numprimes;
}

//incremental - tinkering 1
tpPrime SoA_I1(const tpPrime limit, uint8_t sv[], void*, void*)
{
	const tpPrime svlen = (limit / 96) + 2;
	uint8_t* sieve1 = sv;			  uint8_t* sieve5 = sieve1 + svlen;
	uint8_t* sieve7 = sieve5 + svlen; uint8_t* sieve11 = sieve7 + svlen;

	auto GetBit = [&](tpPrime n, uint8_t sieve[])
	{
		tpPrime q = (n / 12) / 8, r = (n / 12) % 8;
		return (sieve[q] & BIT_MASK[r]);
	};
	auto ResetBit = [&](tpPrime n, uint8_t sieve[])
	{
		tpPrime q = (n / 12) / 8, r = (n / 12) % 8;
		sieve[q] &= BIT_RESET_MASK[r];
	};
	auto FlipBit = [&](tpPrime n, uint8_t sieve[])
	{
		tpPrime q = (n / 12) / 8, r = (n / 12) % 8;
		sieve[q] ^= BIT_MASK[r];
	};


	// 2 and 3 are not generated by the alghorithm
	tpPrime i, numprimes = 2; AddPrime(2); AddPrime(3);
	for (i = 0; i < 4 * svlen; i++) sv[i] = false;

	auto Sieve2 = [&]<typename FN1, typename FN2>(FN1 fn1, FN2 fn2)
	{
		tpPrime iter_min = 0;
		if (limit > STEP_SIZE)
			for (; iter_min < (limit - STEP_SIZE); iter_min += STEP_SIZE)
			{
				fn1(iter_min, iter_min + STEP_SIZE);
				fn2(iter_min, iter_min + STEP_SIZE);
			}
		fn1(iter_min, limit); fn2(iter_min, limit);
	};

	auto Sieve1 = [&]<typename FN>(FN fn1)
	{
		tpPrime iter_min = 0;
		if (limit > STEP_SIZE)
			for (; iter_min < (limit - STEP_SIZE); iter_min += STEP_SIZE)
			{
				fn1(iter_min, iter_min + STEP_SIZE);
			}
		fn1(iter_min, limit);
	};

	cTimer tmr;
	tmr.Start();

	//1 mod 12
	auto Pattern11 = [&](const tpPrime start, const tpPrime stop)
	{
		const tpPrime xmax = (tpPrime)floor(sqrt(stop / 4));
		for (tpPrime x = 1, jmp = 0; x <= xmax; x += (1 + jmp), jmp = 1 - jmp)
		{
			//get in position
			tpPrime y, n0 = 4 * x * x;
			if (n0 < start)
			{
				const tpPrime yy = (tpPrime)ceil(sqrt(start - n0));
				y = 6 * (yy / 6) + 3;
				if (y < yy) y += 6;
			}
			else y = 3;
			//sieve
			for (; ; y += 6)
			{
				tpPrime n = n0 + (y * y);
				if (n > stop) break;
				FlipBit(n, sieve1);
			}
		}
	};
	auto Pattern12 = [&](const tpPrime start, const tpPrime stop)
	{
		//for x = 0 we can not start with y = 1
		uint8_t step = 2;
		const tpPrime yy = (tpPrime)ceil(sqrt(start));
		tpPrime y = 6 * (yy / 6) + 5;
		if (y < yy)
		{
			y += 2;
			if (y < yy) y += 4;
			else step = 4;
		}
		for (; ; y += step, step = 6 - step)
		{
			tpPrime n = y * y;
			if (n > stop) break;
			FlipBit(n, sieve1);
		}
		const tpPrime xmax = (tpPrime)floor(sqrt(stop / 4));
		for (tpPrime x = 3; x <= xmax; x += 3)
		{
			//get in position
			uint8_t step = 4;
			tpPrime y, n0 = 4 * x * x;
			if (n0 < start)
			{
				const tpPrime yy = (tpPrime)ceil(sqrt(start - n0));
				y = 6 * (yy / 6) + 1;
				if (y < yy)
				{
					y += 4;
					if (y < yy) y += 2;
					else step = 2;
				}
			}
			else y = 1;
			//sieve
			for (; ; y += step, step = 6 - step)
			{
				tpPrime n = (4 * x * x) + (y * y);
				if (n > stop) break;
				FlipBit(n, sieve1);
			}
		}
	};
	Sieve2(Pattern11, Pattern12);
	tmr.LapTime(true, "ptrn1");

	//5 mod 12
	auto Pattern5 = [&](const tpPrime start, const tpPrime stop)
	{
		const tpPrime xmax = (tpPrime)floor(sqrt(stop / 4));
		for (tpPrime x = 1, jmp = 0; x <= xmax; x += 1 + jmp, jmp = 1 - jmp)
		{
			//get in position
			uint8_t step = 4;
			tpPrime y, n0 = 4 * x * x;
			if (n0 < start)
			{
				const tpPrime yy = (tpPrime)ceil(sqrt(start - n0));
				y = 6 * (yy / 6) + 1;
				if (y < yy)
				{
					y += 4;
					if (y < yy) y += 2;
					else step = 2;
				}
			}
			else y = 1;
			//sieve
			for (; ; y += step, step = 6 - step)
			{
				tpPrime n = n0 + (y * y);
				if (n > stop) break;
				FlipBit(n, sieve5);
			}
		}
	};
	Sieve1(Pattern5);
	tmr.LapTime(true, "ptrn5");

	//7 mod 12
	auto Pattern7 = [&](const tpPrime start, const tpPrime stop)
	{
		const tpPrime xmax = (tpPrime)floor(sqrt(stop / 3));
		for (tpPrime x = 1; x <= xmax; x += 2)
		{
			//get in position
			uint8_t step = 2;
			tpPrime y, n0 = 3 * x * x;
			if (n0 < start)
			{
				const tpPrime yy = (tpPrime)ceil(sqrt(start - n0));
				y = 6 * (yy / 6) + 2;
				if (y < yy)
				{
					y += 2;
					if (y < yy) y += 4;
					else step = 4;
				}
			}
			else y = 2;
			//sieve			
			for (; ; y += step, step = 6 - step)
			{
				tpPrime n = n0 + (y * y);
				if (n > stop) break;
				FlipBit(n, sieve7);
			}
		}
	};
	Sieve1(Pattern7);
	tmr.LapTime(true, "ptrn7");

	//11 mod 12
	auto Pattern111 = [&](const tpPrime start, const tpPrime stop)
	{
		const tpPrime xmax = (tpPrime)floor(sqrt(stop / 2));
		tpPrime x = (tpPrime)ceil(sqrt(start / 3));
		if (x & 1) x++;
		for (; x <= xmax; x += 2)
		{
			//get in position
			uint8_t step = 4;
			tpPrime y, n0 = 3 * x * x;
			if (n0 > stop)
			{
				const tpPrime yy = (tpPrime)ceil(sqrt(n0 - stop));
				y = 6 * (yy / 6) + 1;
				if (y < yy)
				{
					y += 4;
					if (y < yy) y += 2;
					else step = 2;
				}
			}
			else y = 1;
			//sieve			
			for (; x > y; y += step, step = 6 - step)
			{
				tpPrime n = n0 - (y * y);
				if (n < start) break;
				FlipBit(n, sieve11);
			}
		}
	};
	auto Pattern112 = [&](const tpPrime start, const tpPrime stop)
	{
		const tpPrime xmax = (tpPrime)floor(sqrt(stop / 2));
		tpPrime x = (tpPrime)ceil(sqrt(start / 3));
		if (not (x & 1)) x++;
		for (; x <= xmax; x += 2)
		{
			//get in position
			uint8_t step = 2;
			tpPrime y, n0 = 3 * x * x;
			if (n0 > stop)
			{
				const tpPrime yy = (tpPrime)ceil(sqrt(n0 - stop));
				y = 6 * (yy / 6) + 2;
				if (y < yy)
				{
					y += 2;
					if (y < yy) y += 4;
					else step = 4;
				}
			}
			else y = 2;
			//sieve			
			for (; x > y; y += step, step = 6 - step)
			{
				tpPrime n = n0 - (y * y);
				if (n < start) break;
				FlipBit(n, sieve11);
			}
		}
	};
	Sieve2(Pattern111, Pattern112);

	tmr.LapTime(true, "ptrn11");

	// secondary loop - remove multiple of squares
	auto MarkSquares = [&](uint8_t work_sieve[], const unsigned rem)
	{
		auto MarkOneSquare = [&](uint8_t sieve[], const tpPrime n)
		{
			if (GetBit(n, sieve))
				for (tpPrime i = rem * n * n; i < limit; i += 12 * n * n)
					ResetBit(i, work_sieve);
		};

		MarkOneSquare(sieve5, 5);
		MarkOneSquare(sieve7, 7);
		MarkOneSquare(sieve11, 11);
		for (tpPrime k = 12; k < sqrt(limit); k += 12)
		{
			MarkOneSquare(sieve1, k + 1);
			MarkOneSquare(sieve5, k + 5);
			MarkOneSquare(sieve7, k + 7);
			MarkOneSquare(sieve11, k + 11);
		}
	};
	MarkSquares(sieve1, 1); MarkSquares(sieve5, 5);
	MarkSquares(sieve7, 7); MarkSquares(sieve11, 11);
	tmr.LapTime(true, "squares");

	// last loop - get primes
	auto CountOnePrime = [&](const tpPrime n)
	{ /*if (n < limit)*/ { numprimes++; AddPrime(n); } };
	for (tpPrime k = 0; k < svlen; k++)
	{
		uint8_t sv1 = sieve1[k], sv5 = sieve5[k], sv7 = sieve7[k], sv11 = sieve11[k];
		for (unsigned b = 0; b < 8; b++)
		{
			tpPrime n = 12 * (8 * k + b);
			if (sv1 & BIT_MASK[b]) CountOnePrime(n + 1);
			if (sv5 & BIT_MASK[b]) CountOnePrime(n + 5);
			if (sv7 & BIT_MASK[b]) CountOnePrime(n + 7);
			if (sv11 & BIT_MASK[b]) CountOnePrime(n + 11);
		}
	}

	tmr.LapTime(true, "counting");
	tmr.Stop(/*true, "squares & counting"*/);
	return numprimes;
}

//incremental - tinkering 2
tpPrime SoA_I2(const tpPrime limit, uint8_t sv[], void*, void*)
{
	const tpPrime svlen = (limit / 96) + 2;
	uint8_t* sieve1 = sv;			  uint8_t* sieve5 = sieve1 + svlen;
	uint8_t* sieve7 = sieve5 + svlen; uint8_t* sieve11 = sieve7 + svlen;

	auto GetBit = [&](tpPrime n, uint8_t sieve[])
	{
		tpPrime q = (n / 12) / 8, r = (n / 12) % 8;
		return (sieve[q] & BIT_MASK[r]);
	};
	auto ResetBit = [&](tpPrime n, uint8_t sieve[])
	{
		tpPrime q = (n / 12) / 8, r = (n / 12) % 8;
		sieve[q] &= BIT_RESET_MASK[r];
	};
	auto FlipBit = [&](tpPrime n, uint8_t sieve[])
	{
		tpPrime q = (n / 12) / 8, r = (n / 12) % 8;
		sieve[q] ^= BIT_MASK[r];
	};

	// 2 and 3 are not generated by the alghorithm
	tpPrime i, numprimes = 2; AddPrime(2); AddPrime(3);
	for (i = 0; i < 4 * svlen; i++) sv[i] = false;

	auto Sieve2 = [&]<typename FN1, typename FN2>(FN1 fn1, FN2 fn2)
	{
		tpPrime iter_min = 0;
		if (limit > STEP_SIZE)
			for (; iter_min < (limit - STEP_SIZE); iter_min += STEP_SIZE)
			{
				fn1(iter_min, iter_min + STEP_SIZE);
				fn2(iter_min, iter_min + STEP_SIZE);
			}
		fn1(iter_min, limit); fn2(iter_min, limit);
	};
	auto Sieve1 = [&]<typename FN>(FN fn1)
	{
		tpPrime iter_min = 0;
		if (limit > STEP_SIZE)
			for (; iter_min < (limit - STEP_SIZE); iter_min += STEP_SIZE)
			{
				fn1(iter_min, iter_min + STEP_SIZE);
			}
		fn1(iter_min, limit);
	};

	cTimer tmr;
	tmr.Start();

	//1 mod 12
	auto Pattern11 = [&](const tpPrime start, const tpPrime stop)
	{
		const tpPrime xmax = (tpPrime)floor(sqrt(stop / 4));
		for (tpPrime x = 1, jmp = 0; x <= xmax; x += (1 + jmp), jmp = 1 - jmp)
		{
			//get in position
			tpPrime y, n0 = 4 * x * x;
			if (n0 < start)
			{
				const tpPrime yy = (tpPrime)ceil(sqrt(start - n0));
				y = 6 * (yy / 6) + 3;
				if (y < yy) y += 6;
			}
			else y = 3;
			//sieve
			for (; ; y += 6)
			{
				tpPrime n = n0 + (y * y);
				if (n > stop) break;
				FlipBit(n, sieve1);
			}
		}
	};
	auto Pattern12 = [&](const tpPrime start, const tpPrime stop)
	{
		//for x = 0 we can not start with y = 1
		uint8_t step = 2;
		const tpPrime yy = (tpPrime)ceil(sqrt(start));
		tpPrime y = 6 * (yy / 6) + 5;
		if (y < yy)
		{
			y += 2;
			if (y < yy) y += 4;
			else step = 4;
		}
		for (; ; y += step, step = 6 - step)
		{
			tpPrime n = y * y;
			if (n > limit) break;
			FlipBit(n, sieve1);
		}
		const tpPrime xmax = (tpPrime)floor(sqrt(limit / 4));
		for (tpPrime x = 3; x <= xmax; x += 3)
		{
			//get in position
			uint8_t step = 4;
			tpPrime y, n0 = 4 * x * x;
			if (n0 < start)
			{
				const tpPrime yy = (tpPrime)ceil(sqrt(start - n0));
				y = 6 * (yy / 6) + 1;
				if (y < yy)
				{
					y += 4;
					if (y < yy) y += 2;
					else step = 2;
				}
			}
			else y = 1;
			//sieve
			for (; ; y += step, step = 6 - step)
			{
				tpPrime n = (4 * x * x) + (y * y);
				if (n > stop) break;
				FlipBit(n, sieve1);
			}
		}
	};
	Sieve2(Pattern11, Pattern12);
	//tmr.LapTime(true, "ptrn1");

	//5 mod 12
	auto Pattern5 = [&](const tpPrime start, const tpPrime stop)
	{
		const tpPrime xmax = (tpPrime)floor(sqrt(stop / 4));
		for (tpPrime x = 1, jmp = 0; x <= xmax; x += 1 + jmp, jmp = 1 - jmp)
		{
			//get in position
			uint8_t step = 4;
			tpPrime y, n0 = 4 * x * x;
			if (n0 < start)
			{
				const tpPrime yy = (tpPrime)ceil(sqrt(start - n0));
				y = 6 * (yy / 6) + 1;
				if (y < yy)
				{
					y += 4;
					if (y < yy) y += 2;
					else step = 2;
				}
			}
			else y = 1;
			//sieve
			for (; ; y += step, step = 6 - step)
			{
				tpPrime n = n0 + (y * y);
				if (n > stop) break;
				FlipBit(n, sieve5);
			}
		}
	};
	Sieve1(Pattern5);
	//tmr.LapTime(true, "ptrn5");

	//7 mod 12
	auto Pattern7 = [&](const tpPrime start, const tpPrime stop)
	{
		const tpPrime xmax = (tpPrime)floor(sqrt(stop / 3));
		for (tpPrime x = 1; x <= xmax; x += 2)
		{
			//get in position
			uint8_t step = 2;
			tpPrime y, n0 = 3 * x * x;
			if (n0 < start)
			{
				const tpPrime yy = (tpPrime)ceil(sqrt(start - n0));
				y = 6 * (yy / 6) + 2;
				if (y < yy)
				{
					y += 2;
					if (y < yy) y += 4;
					else step = 4;
				}
			}
			else y = 2;
			//sieve			
			for (; ; y += step, step = 6 - step)
			{
				tpPrime n = n0 + (y * y);
				if (n > stop) break;
				FlipBit(n, sieve7);
			}
		}
	};
	Sieve1(Pattern7);
	//tmr.LapTime(true, "ptrn7");

	//11 mod 12
	auto Pattern111 = [&](const tpPrime start, const tpPrime stop)
	{
		const tpPrime xmax = (tpPrime)floor(sqrt(stop / 2));
		tpPrime x = (tpPrime)ceil(sqrt(start / 3));
		if (x & 1) x++;
		for (; x <= xmax; x += 2)
		{
			//get in position
			uint8_t step = 4;
			tpPrime y, n0 = 3 * x * x;
			if (n0 > stop)
			{
				const tpPrime yy = (tpPrime)ceil(sqrt(n0 - stop));
				y = 6 * (yy / 6) + 1;
				if (y < yy)
				{
					y += 4;
					if (y < yy) y += 2;
					else step = 2;
				}
			}
			else y = 1;
			//sieve			
			for (; x > y; y += step, step = 6 - step)
			{
				tpPrime n = n0 - (y * y);
				if (n < start) break;
				FlipBit(n, sieve11);
			}
		}
	};
	auto Pattern112 = [&](const tpPrime start, const tpPrime stop)
	{
		const tpPrime xmax = (tpPrime)floor(sqrt(stop / 2));
		tpPrime x = (tpPrime)ceil(sqrt(start / 3));
		if (not (x & 1)) x++;
		for (; x <= xmax; x += 2)
		{
			//get in position
			uint8_t step = 2;
			tpPrime y, n0 = 3 * x * x;
			if (n0 > stop)
			{
				const tpPrime yy = (tpPrime)ceil(sqrt(n0 - stop));
				y = 6 * (yy / 6) + 2;
				if (y < yy)
				{
					y += 2;
					if (y < yy) y += 4;
					else step = 4;
				}
			}
			else y = 2;
			//sieve			
			for (; x > y; y += step, step = 6 - step)
			{
				tpPrime n = n0 - (y * y);
				if (n < start) break;
				FlipBit(n, sieve11);
			}
		}
	};
	Sieve2(Pattern111, Pattern112);

	tmr.LapTime(true, "ptrn11");

	// secondary loop - remove multiple of squares
	auto MarkSquares = [&](uint8_t work_sieve[], const unsigned rem)
	{
		auto MarkOneSquare = [&](uint8_t sieve[], const tpPrime n)
		{
			//tpPrime istp = 12 * n * n;
			if (GetBit(n, sieve))
				for (tpPrime i = rem * n * n; i < limit; i += 12 * n * n)
					ResetBit(i, work_sieve);
		};

		tpPrime kmax = (tpPrime)floor(sqrt(limit));

		//for (tpPrime k = 12; k < kmax; k += 12)
		//	MarkOneSquare(sieve1, k + 1);
		//for (tpPrime k = 0; k < kmax; k += 12)
		//	MarkOneSquare(sieve5, k + 5);
		//for (tpPrime k = 0; k < kmax; k += 12)
		//	MarkOneSquare(sieve7, k + 7);
		//for (tpPrime k = 0; k < kmax; k += 12)
		//	MarkOneSquare(sieve11, k + 11);

			MarkOneSquare(sieve5, 5);
			MarkOneSquare(sieve7, 7);
			MarkOneSquare(sieve11, 11);
		for (tpPrime k = 12; k < kmax; k += 12)
		{
			MarkOneSquare(sieve1, k + 1);
			MarkOneSquare(sieve5, k + 5);
			MarkOneSquare(sieve7, k + 7);
			MarkOneSquare(sieve11, k + 11);
		}
	};
	MarkSquares(sieve1, 1); MarkSquares(sieve5,  5);
	MarkSquares(sieve7, 7); MarkSquares(sieve11, 11);
	tmr.LapTime(true, "squares");

	// last loop - get primes
	for (tpPrime k = 0; k < svlen; k++)
	{
		uint8_t sv1 = sieve1[k], sv5 = sieve5[k], sv7 = sieve7[k], sv11 = sieve11[k];
		auto CountPrime = [&](const tpPrime n) { numprimes++; AddPrime(n); };
		auto CountPrimes = [&](const unsigned b)
		{
			tpPrime n = 12 * (8 * k + b);
			if (sv1 & BIT_MASK[b]) CountPrime(n + 1);
			if (sv5 & BIT_MASK[b]) CountPrime(n + 5);
			if (sv7 & BIT_MASK[b]) CountPrime(n + 7);
			if (sv11 & BIT_MASK[b]) CountPrime(n + 11);
		};
		CountPrimes(0); CountPrimes(1); CountPrimes(2); CountPrimes(3);
		CountPrimes(4); CountPrimes(5); CountPrimes(6); CountPrimes(7);
	}

	tmr.LapTime(true, "counting");
	tmr.Stop(/*true, "squares & counting"*/);
	return numprimes;
}

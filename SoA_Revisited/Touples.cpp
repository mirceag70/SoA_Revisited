#include "Helper.h"

struct sKs { unsigned char dx, dy; };

template<std::size_t const arr_length, typename fN>
consteval auto xy_generic(unsigned const char rem, const fN&& f)
{
	unsigned char k, i, j;
	std::array<sKs, arr_length> arr{};
	for (k = i = 0; i < 12; i++)
		for (j = 0; j < 12; j++)
		{
			int n = (int)f(i, j);
			if (n < 0) n = 1200 + n;
			if ((n % 12) == rem)
			{
				arr[k].dx = i;
				arr[k].dy = j;
				k++;
			}
		}
	return arr;
};

struct cTuples
{
public:
	inline static const unsigned char size_1n5 = 32;
	inline static const unsigned char size_7 = 24;
	inline static const unsigned char size_11 = 48;

	inline static constexpr auto xy_1 = xy_generic <size_1n5>(1,
		[](tpPrime x, tpPrime  y) { return 4 * x * x + y * y; });
	inline static constexpr auto xy_5 = xy_generic <size_1n5>(5,
		[](tpPrime x, tpPrime  y) { return 4 * x * x + y * y; });
	inline static constexpr auto xy_7 = xy_generic <size_7>(7,
		[](tpPrime x, tpPrime  y) { return 3 * x * x + y * y; });
	inline static constexpr auto xy_11 = xy_generic <size_11>(11,
		[](tpPrime x, tpPrime  y) { return 3 * x * x - y * y; });

	static_assert(xy_7[1].dx == 1);
	static_assert(xy_5[3].dy == 11);
};

cTuples tuples;

template<typename T1>
constexpr auto FLIP2(const T1 vect, const size_t pos) { vect[(pos) / 2] ^= true; }

template<typename T1>
constexpr auto GET2(T1 vect, size_t pos) { return vect[(pos) / 2]; }

template<typename T1>
constexpr auto RESET2(T1 vect, size_t pos) { vect[pos / 2] = false; }

//template<typename T1>
//constexpr auto FLIP(T1 vect, size_t pos) { vect[pos] ^= true; }
//
//template<typename T1>
//constexpr auto GET(T1 vect, size_t pos) { return vect[pos]; }
//
//template<typename T1>
//constexpr auto RESET(T1 vect, size_t pos) { vect[pos] = false; }

template<typename FL, typename FN, size_t SZ>
constexpr void ProcessQuadraticsPls(const tpPrime limit,
	bool* sieve, const std::array<sKs, SZ>& vc,
	FL FN_lp, FN FN_n)
{
	for (tpPrime x = 0; FN_lp(x) < limit; x += 12)
		for (tpPrime y = 0; ; y += 12)
		{
			unsigned work = false;
			for (unsigned char i = 0; i < SZ; i++)
			{
				tpPrime n = FN_n(x + vc[i].dx, y + vc[i].dy);
				if (n <= limit)
				{
					FLIP2(sieve, n);
					work = true;
				}
			}
			if (!work)
				break;
		}
}

template<typename FL, typename FN, size_t SZ>
constexpr void ProcessQuadraticsMns(const tpPrime limit,
	bool* sieve, const std::array<sKs, SZ>& vc,
	FL FN_lp, FN FN_n)
{
	for (tpPrime x = 0; FN_lp(x) < limit; x += 12)
		for (tpPrime y = 0; y <= x; y += 12)
		{
			for (unsigned char i = 0; i < SZ; i++)
				if (x + vc[i].dx > y + vc[i].dy)
				{
					tpPrime n = FN_n(x + vc[i].dx, y + vc[i].dy);
					if (n <= limit)
					{
						FLIP2(sieve, n);
					}
				}
		}
}

tpPrime SoA_T(const tpPrime limit, bool sieve[], void*, void*)
{
	for (tpPrime i = 0; i < limit/2; i++) sieve[i] = false;

	// 2 and 3 are not generated by the alghorithm
	tpPrime numprimes = 2; 
	FLIP2(sieve, 2); AddPrime(2); FLIP2(sieve, 3); AddPrime(3);

	ProcessQuadraticsPls(limit, sieve, tuples.xy_1,
		[](tpPrime x) { return 4 * x * x; },
		[](tpPrime x, tpPrime y) { return 4 * x * x + y * y; });

	ProcessQuadraticsPls(limit, sieve, tuples.xy_5,
		[](tpPrime x) { return 4 * x * x; },
		[](tpPrime x, tpPrime y) { return 4 * x * x + y * y; });

	ProcessQuadraticsPls(limit, sieve, tuples.xy_7,
		[](tpPrime x) { return 3 * x * x; },
		[](tpPrime x, tpPrime y) { return 3 * x * x + y * y; });

	ProcessQuadraticsMns(limit, sieve, tuples.xy_11,
		[](tpPrime x) { return 2 * x * x; },
		[](tpPrime x, tpPrime y) { return 3 * x * x - y * y; });

	auto Loop1 = [&](tpPrime i)
	{
		if (GET2(sieve, i))
		{
			numprimes++; AddPrime(i);
			for (tpPrime j = i * i; j < limit; j += 2 * i * i)
				RESET2(sieve, j);
		}
	};

	auto Loop2 = [&](tpPrime i)
	{
		if (GET2(sieve, i))
		{
			numprimes++; AddPrime(i);
		}
	};

	tpPrime i;
	// secondary loop - remove multiple of squares
	for (i = 6; i * i < limit; i += 6)
	{
		Loop1(i - 1); Loop1(i + 1);
	}

	// last loop - get primes
	for (; i < limit; i += 6)
	{
		Loop2(i - 1); Loop2(i + 1);
	}

	return numprimes;
}

void Count6k(tpPrime& numPrimes, tpPrime p, uint8_t sieve[], const uint64_t Nmax)
{
	uint64_t i = (p - 5) / 24;
	uint64_t pbase = (i * 24) + 5;
	uint8_t step, b = (uint8_t)(p - pbase);
	switch (b)
	{
	case 0: b = 0; step = 2; break;
	case 2: b = 1; step = 4; break;
	case 6: b = 2; step = 2; break;
	case 8: b = 3; step = 4; break;
	case 12: b = 4; step = 2; break;
	case 14: b = 5; step = 4; break;
	case 18: b = 6; step = 2; break;
	case 20: b = 7; step = 4; break;
	default: assert(false);
	}
	uint8_t flags = sieve[i];
	//assert(flags & BIT_MASK[b]);
	for (; b < 8; b++)
	{
		if (flags & BIT_MASK[b]) { numPrimes++; AddPrime(p); }
		p += step; step = 6 - step;
	}
	const uint64_t i_max = Nmax / 24;
	for (i++; i < i_max - 1; i++)
	{
		flags = sieve[i];
		if (flags & BIT_MASK[0]) { numPrimes++; AddPrime(p); }
		if (flags & BIT_MASK[1]) { numPrimes++; AddPrime(p + 2); }
		if (flags & BIT_MASK[2]) { numPrimes++; AddPrime(p + 6); }
		if (flags & BIT_MASK[3]) { numPrimes++; AddPrime(p + 8); }
		if (flags & BIT_MASK[4]) { numPrimes++; AddPrime(p + 12); }
		if (flags & BIT_MASK[5]) { numPrimes++; AddPrime(p + 14); }
		if (flags & BIT_MASK[6]) { numPrimes++; AddPrime(p + 18); }
		if (flags & BIT_MASK[7]) { numPrimes++; AddPrime(p + 20); }
		p += 24;
	}
	while (p <= Nmax)
	{
		flags = sieve[i++];
		for (b = 0; b < 8; b++)
		{
			if (p > Nmax) break;
			if (flags & BIT_MASK[b]) { numPrimes++; AddPrime(p); }
			p += step; step = 6 - step;
		}
	}
}

//with tuples
tpPrime SoA_T1(const tpPrime limit, uint8_t sieve[], void*, void*)
{
	auto GetBit = [&](tpPrime n)
	{
		tpPrime bitidx = no2idx(n);
		uint64_t idx = bitidx / 8, bit = (uint8_t)(bitidx % 8);
		return (sieve[idx] & BIT_MASK[bit]);
	};
	auto ResetBit = [&](tpPrime n)
	{
		tpPrime bitidx = no2idx(n);
		uint64_t idx = bitidx / 8, bit = (uint8_t)(bitidx % 8);
		sieve[idx] &= BIT_RESET_MASK[bit];
	};
	auto FlipBit = [&](tpPrime n)
	{
		tpPrime bitidx = no2idx(n);
		uint64_t idx = bitidx / 8, bit = (uint8_t)(bitidx % 8);
		sieve[idx] ^= BIT_MASK[bit];
	};
	auto ProcessQuadratics157 = [&]<typename FN, size_t SZ>
		(const uint8_t a, const std::array<sKs, SZ>& vc, FN fn)
	{
		const tpPrime xmax = (tpPrime)floor(sqrt(limit / a));
		for (tpPrime x = 0; x < xmax; x += 12)
			for (tpPrime y = 0;; y += 12)
			{
				unsigned stop = true;
				for (unsigned char i = 0; i < SZ; i++)
				{
					tpPrime n = fn(x + vc[i].dx, y + vc[i].dy);
					if (n>4 and n <= limit)
					{
						FlipBit(n);
						stop = false;
					}
				}
				if (stop) break;
			}
	};
	auto ProcessQuadratics11 = [&]<typename FN, size_t SZ>
		(const uint8_t a, const std::array<sKs, SZ>& vc, FN fn)
	{
		const tpPrime xmax = (tpPrime)floor(sqrt(limit / a));
		for (tpPrime x = 0; x < xmax; x += 12)
			for (tpPrime y = 0; y <= x; y += 12)
				for (unsigned char i = 0; i < SZ; i++)
					if (x + vc[i].dx > y + vc[i].dy)
					{
						tpPrime n = fn(x + vc[i].dx, y + vc[i].dy);
						if (n <= limit)
							FlipBit(n);
					}
	};

	// 2 and 3 are not generated by the alghorithm
	tpPrime i, numprimes = 2; AddPrime(2); AddPrime(3);
	for (i = 0; i <= limit / 24; i++) sieve[i] = false;

	ProcessQuadratics157(4, tuples.xy_1,
		[](tpPrime x, tpPrime y) { return 4 * x * x + y * y; });
	ProcessQuadratics157(4, tuples.xy_5,
		[](tpPrime x, tpPrime y) { return 4 * x * x + y * y; });
	ProcessQuadratics157(3, tuples.xy_7,
		[](tpPrime x, tpPrime y) { return 3 * x * x + y * y; });
	ProcessQuadratics11(2, tuples.xy_11,
		[](tpPrime x, tpPrime y) { return 3 * x * x - y * y; });

	cTimer tmr;
	//tmr.Start();

	auto Loop1 = [&](tpPrime i)
	{
		if (GetBit(i))
		{
			int step = 2;
			numprimes++; AddPrime(i);
			for (tpPrime j = i * i; j < limit; j += step * i * i)
			{
				ResetBit(j);
				step = 6 - step;
			}
		}
	};
	// secondary loop - remove multiple of squares
	for (i = 6; i * i < limit; i += 6)
		{ Loop1(i - 1); Loop1(i + 1); }

	//tmr.LapTime(true, "squares");

	auto Loop2 = [&](tpPrime i)
	{ if (GetBit(i)) { numprimes++; AddPrime(i); } };
	//last loop - get primes
	for (; i < limit; i += 6)
	{ 
		Loop2(i - 1); 
		Loop2(i + 1); 
	}

	//Count6k(numprimes, i - 1, sieve, limit);

	//tmr.LapTime(true, "counting");
	//tmr.Stop();
	return numprimes;
}

//with pattern
tpPrime SoA_T2(const tpPrime limit, uint8_t sieve[], void*, void*)
{
	auto GetBit = [&](tpPrime n)
	{
		tpPrime bitidx = no2idx(n);
		uint64_t idx = bitidx / 8, bit = (uint8_t)(bitidx % 8);
		return (sieve[idx] & BIT_MASK[bit]);
	};
	auto ResetBit = [&](tpPrime n)
	{
		tpPrime bitidx = no2idx(n);
		uint64_t idx = bitidx / 8, bit = (uint8_t)(bitidx % 8);
		sieve[idx] &= BIT_RESET_MASK[bit];
	};
	auto FlipBit = [&](tpPrime n)
	{
		tpPrime bitidx = no2idx(n);
		uint64_t idx = bitidx / 8, bit = (uint8_t)(bitidx % 8);
		sieve[idx] ^= BIT_MASK[bit];
	};

	// 2 and 3 are not generated by the alghorithm
	tpPrime i, numprimes = 2; AddPrime(2); AddPrime(3);
	for (i = 0; i <= limit / 24; i++) sieve[i] = false;

	//1 mod 12
	const tpPrime xmax4 = (tpPrime)floor(sqrt(limit / 4));
	//uint8_t jmp = 0;
	for (tpPrime x = 1, jmp = 0; x <= xmax4; x += 1 + jmp, jmp = 1 - jmp)
	{
		for (tpPrime y = 3; ; y += 6)
		{
			tpPrime n = (4 * x * x) + (y * y);
			if (n > limit) break;
			FlipBit(n);
		}
	}
	for (tpPrime x = 0; x <= xmax4; x += 3)
	{
		uint8_t step = 4;
		for (tpPrime y = 1; ; y += step, step = 6 - step)
		{
			tpPrime n = (4 * x * x) + (y * y);
			if (n > limit) break;
			if (n > 4) FlipBit(n);
		}
	}
	//5 mod 12
	for (tpPrime x = 1, jmp = 0; x <= xmax4; x += 1 + jmp, jmp = 1 - jmp)
	{
		uint8_t step = 4;
		for (tpPrime y = 1; ; y += step, step = 6 - step)
		{
			tpPrime n = (4 * x * x) + (y * y);
			if (n > limit) break;
			FlipBit(n);
		}
	}

	//7 mod 12
	const tpPrime xmax3 = (tpPrime)floor(sqrt(limit / 3));
	for (tpPrime x = 1; x <= xmax3; x += 2)
	{
		uint8_t step = 2;
		for (tpPrime y = 2; ; y += step, step = 6 - step)
		{
			tpPrime n = (3 * x * x) + (y * y);
			if (n > limit) break;
			FlipBit(n);
		}
	}

	//11 mod 12
	const tpPrime xmax2 = (tpPrime)floor(sqrt(limit / 2));
	for (tpPrime x = 2; x <= xmax2; x += 2)
	{
		uint8_t step = 4;
		for (tpPrime y = 1; x > y; y += step, step = 6 - step)
		{
			tpPrime n = (3 * x * x) - (y * y);
			if (n <= limit) 
				FlipBit(n);
		}
	}
	for (tpPrime x = 1; x <= xmax2; x += 2)
	{
		uint8_t step = 2;
		for (tpPrime y = 2; x > y; y += step, step = 6 - step)
		{
			tpPrime n = (3 * x * x) - (y * y);
			if (n <= limit)
				FlipBit(n);
		}
	}

	cTimer tmr;
	tmr.Start();

	// secondary loop - remove multiple of squares
	auto Loop1 = [&](tpPrime i)
	{
		if (GetBit(i))
		{
			int step = 2;
			numprimes++; AddPrime(i);
			for (tpPrime j = i * i; j < limit; j += step * i * i)
			{
				ResetBit(j);
				step = 6 - step;
			}
		}
	};
	for (i = 6; i * i < limit; i += 6)
	{ Loop1(i - 1); Loop1(i + 1); }

	//tmr.LapTime(true, "squares");

	// last loop - get primes
	Count6k(numprimes, i - 1, sieve, limit);

	//tmr.LapTime(true, "counting");
	tmr.Stop(true,"squares & counting");
	return numprimes;
}

//with pattern & 4 sieve buffers
tpPrime SoA_T3(const tpPrime limit, uint8_t sv[], void*, void*)
{
	const tpPrime svlen = (limit / 96) + 2;
	uint8_t* sieve1 = sv;			  uint8_t* sieve5  = sieve1 + svlen;
	uint8_t* sieve7 = sieve5 + svlen; uint8_t* sieve11 = sieve7 + svlen;

	auto GetBit = [&](tpPrime n, uint8_t sieve[])
	{
		tpPrime q = (n / 12) / 8, r = (n / 12) % 8;
		return (sieve[q] & BIT_MASK[r]);
	};
	auto ResetBit = [&](tpPrime n, uint8_t sieve[])
	{
		tpPrime q = (n / 12) / 8, r = (n / 12) % 8;
		sieve[q] &= BIT_RESET_MASK[r];
	};
	auto FlipBit = [&](tpPrime n, uint8_t sieve[])
	{
		tpPrime q = (n / 12) / 8, r = (n / 12) % 8;
		sieve[q] ^= BIT_MASK[r];
	};

	// 2 and 3 are not generated by the alghorithm
	tpPrime i, numprimes = 2; AddPrime(2); AddPrime(3);
	for (i = 0; i < 4*svlen; i++) sv[i] = false;

	//1 mod 12
	const tpPrime xmax4 = (tpPrime)floor(sqrt(limit / 4));
	//uint8_t jmp = 0;
	for (tpPrime x = 1, jmp = 0; x <= xmax4; x += 1 + jmp, jmp = 1 - jmp)
	{
		for (tpPrime y = 3; ; y += 6)
		{
			tpPrime n = (4 * x * x) + (y * y);
			if (n > limit) break;
			FlipBit(n, sieve1);
		}
	}
	for (tpPrime x = 0; x <= xmax4; x += 3)
	{
		uint8_t step = 4;
		for (tpPrime y = 1; ; y += step, step = 6 - step)
		{
			tpPrime n = (4 * x * x) + (y * y);
			if (n > limit) break;
			if (n > 4) FlipBit(n, sieve1);
		}
	}

	//5 mod 12
	for (tpPrime x = 1, jmp = 0; x <= xmax4; x += 1 + jmp, jmp = 1 - jmp)
	{
		uint8_t step = 4;
		for (tpPrime y = 1; ; y += step, step = 6 - step)
		{
			tpPrime n = (4 * x * x) + (y * y);
			if (n > limit) break;
			FlipBit(n, sieve5);
		}
	}

	//7 mod 12
	const tpPrime xmax3 = (tpPrime)floor(sqrt(limit / 3));
	for (tpPrime x = 1; x <= xmax3; x += 2)
	{
		uint8_t step = 2;
		for (tpPrime y = 2; ; y += step, step = 6 - step)
		{
			tpPrime n = (3 * x * x) + (y * y);
			if (n > limit) break;
			FlipBit(n, sieve7);
		}
	}

	//11 mod 12
	const tpPrime xmax2 = (tpPrime)floor(sqrt(limit / 2));
	for (tpPrime x = 2; x <= xmax2; x += 2)
	{
		uint8_t step = 4;
		for (tpPrime y = 1; x > y; y += step, step = 6 - step)
		{
			tpPrime n = (3 * x * x) - (y * y);
			if (n <= limit)
				FlipBit(n, sieve11);
		}
	}
	for (tpPrime x = 1; x <= xmax2; x += 2)
	{
		uint8_t step = 2;
		for (tpPrime y = 2; x > y; y += step, step = 6 - step)
		{
			tpPrime n = (3 * x * x) - (y * y);
			if (n <= limit)
				FlipBit(n, sieve11);
		}
	}

	cTimer tmr;
	tmr.Start();

	// secondary loop - remove multiple of squares
	auto MarkSquares = [&](uint8_t work_sieve[], const unsigned rem)
	{
		auto MarkOneSquare = [&](uint8_t sieve[], const tpPrime n)
		{
			if (GetBit(n, sieve))
				for (tpPrime i = rem * n * n; i < limit; i += 12 * n * n)
					ResetBit(i, work_sieve);
		};

		MarkOneSquare(sieve5, 5);
		MarkOneSquare(sieve7, 7);
		MarkOneSquare(sieve11, 11);
		for (tpPrime k = 12; k < sqrt(limit); k += 12)
		{
			MarkOneSquare(sieve1, k + 1);
			MarkOneSquare(sieve5, k + 5);
			MarkOneSquare(sieve7, k + 7);
			MarkOneSquare(sieve11, k + 11);
		}
	};
	MarkSquares(sieve1, 1);
	MarkSquares(sieve5, 5);
	MarkSquares(sieve7, 7);
	MarkSquares(sieve11, 11);
	tmr.LapTime(/*true, "squares"*/);

	// last loop - get primes
	auto CountOnePrime = [&](uint8_t sieve[], const tpPrime k, const unsigned b, const unsigned rem)
	{
		if (sieve[k] & BIT_MASK[b])
		{
			tpPrime n = 12 * (8*k + b) + rem;
			if (n < limit)
			{ numprimes++; AddPrime(n); }
		}
	};
	for (tpPrime k = 0; k <= svlen; k++)
	for (unsigned b = 0; b <8; b++)
	{
		CountOnePrime(sieve1,  k, b, 1);
		CountOnePrime(sieve5,  k, b, 5);
		CountOnePrime(sieve7,  k, b, 7);
		CountOnePrime(sieve11, k, b, 11);
	}

	tmr.LapTime(true, "counting");
	tmr.Stop(/*true, "squares & counting"*/);
	return numprimes;
}

//with 4 buffers - optimized
tpPrime SoA_T4(const tpPrime limit, uint8_t sv[], void*, void*)
{
	const tpPrime svlen = (limit / 96) + 2;
	uint8_t* sieve1 = sv;			  uint8_t* sieve5 = sieve1 + svlen;
	uint8_t* sieve7 = sieve5 + svlen; uint8_t* sieve11 = sieve7 + svlen;

	auto GetBit = [&](tpPrime n, uint8_t sieve[])
	{
		tpPrime q = (n / 12) / 8, r = (n / 12) % 8;
		return (sieve[q] & BIT_MASK[r]);
	};
	auto ResetBit = [&](tpPrime n, uint8_t sieve[])
	{
		tpPrime q = (n / 12) / 8, r = (n / 12) % 8;
		sieve[q] &= BIT_RESET_MASK[r];
	};
	auto FlipBit = [&](tpPrime n, uint8_t sieve[])
	{
		tpPrime q = (n / 12) / 8, r = (n / 12) % 8;
		sieve[q] ^= BIT_MASK[r];
	};

	// 2 and 3 are not generated by the alghorithm
	tpPrime i, numprimes = 2; AddPrime(2); AddPrime(3);
	for (i = 0; i < 4 * svlen; i++) sv[i] = false;

	cTimer tmr;
	tmr.Start();

	//1 mod 12
	const tpPrime xmax4 = (tpPrime)floor(sqrt(limit / 4));
	//uint8_t jmp = 0;
	for (tpPrime x = 1, jmp = 0; x <= xmax4; x += 1 + jmp, jmp = 1 - jmp)
	{
		for (tpPrime y = 3; ; y += 6)
		{
			tpPrime n = (4 * x * x) + (y * y);
			if (n > limit) break;
			FlipBit(n, sieve1);
		}
	}
	tmr.LapTime(true, "ptrn11");

	{	//fir x = 0 can not start with y = 1
		uint8_t step = 2;
		for (tpPrime y = 5; ; y += step, step = 6 - step)
		{
			tpPrime n = y * y;
			if (n > limit) break;
			FlipBit(n, sieve1);
		}
	}
	for (tpPrime x = 3; x <= xmax4; x += 3)
	{
		uint8_t step = 4;
		for (tpPrime y = 1; ; y += step, step = 6 - step)
		{
			tpPrime n = (4 * x * x) + (y * y);
			if (n > limit) break;
			FlipBit(n, sieve1);
		}
	}
	tmr.LapTime(true, "ptrn12");

	//5 mod 12
	for (tpPrime x = 1, jmp = 0; x <= xmax4; x += 1 + jmp, jmp = 1 - jmp)
	{
		uint8_t step = 4;
		for (tpPrime y = 1; ; y += step, step = 6 - step)
		{
			tpPrime n = (4 * x * x) + (y * y);
			if (n > limit) break;
			FlipBit(n, sieve5);
		}
	}
	tmr.LapTime(true, "ptrn5");

	//7 mod 12
	const tpPrime xmax3 = (tpPrime)floor(sqrt(limit / 3));
	for (tpPrime x = 1; x <= xmax3; x += 2)
	{
		uint8_t step = 2;
		for (tpPrime y = 2; ; y += step, step = 6 - step)
		{
			tpPrime n = (3 * x * x) + (y * y);
			if (n > limit) break;
			FlipBit(n, sieve7);
		}
	}
	tmr.LapTime(true, "ptrn7");

	//11 mod 12
	const tpPrime xmax2 = (tpPrime)floor(sqrt(limit / 2));
	tpPrime x;
	for (x = 2; x <= xmax3; x += 2)
	{
		uint8_t step = 4;
		for (tpPrime y = 1; x > y; y += step, step = 6 - step)
		{
			tpPrime n = (3 * x * x) - (y * y);
			FlipBit(n, sieve11);
		}
	}
	for (; x <= xmax2; x += 2)
	{
		uint8_t step = 4;
		tpPrime yy = (tpPrime)ceil(sqrt(3 * x * x - limit));
		tpPrime y = 6 * (yy / 6) + 1;
		if (y < yy)
		{
			y += 4;
			if (y < yy) y += 2;
			else step = 2;
		}
		for (; x > y; y += step, step = 6 - step)
		{
			tpPrime n = (3 * x * x) - (y * y);
			FlipBit(n, sieve11);
		}
	}	
	tmr.LapTime(true, "ptrn111");

	for (x = 1; x <= xmax3; x += 2)
	{
		uint8_t step = 2;
		for (tpPrime y = 2; x > y; y += step, step = 6 - step)
		{
			tpPrime n = (3 * x * x) - (y * y);
			FlipBit(n, sieve11);
		}
	}
	for (; x <= xmax2; x += 2)
	{
		uint8_t step = 2;
		tpPrime yy = (tpPrime)ceil(sqrt(3 * x * x - limit));
		tpPrime y = 6 * (yy / 6) + 2;
		if (y < yy)
		{
			y += 2;
			if (y < yy) y += 4; 
			else step = 4;
		}
		for (; x > y; y += step, step = 6 - step)
		{
			tpPrime n = (3 * x * x) - (y * y);
			FlipBit(n, sieve11);
		}
	}
	tmr.LapTime(true, "ptrn112");

	// secondary loop - remove multiple of squares
	auto MarkSquares = [&](uint8_t work_sieve[], const unsigned rem)
	{
		auto MarkOneSquare = [&](uint8_t sieve[], const tpPrime n)
		{
			if (GetBit(n, sieve))
				for (tpPrime i = rem * n * n; i < limit; i += 12 * n * n)
					ResetBit(i, work_sieve);
		};

		MarkOneSquare(sieve5, 5);
		MarkOneSquare(sieve7, 7);
		MarkOneSquare(sieve11, 11);
		for (tpPrime k = 12; k < sqrt(limit); k += 12)
		{
			MarkOneSquare(sieve1, k + 1);
			MarkOneSquare(sieve5, k + 5);
			MarkOneSquare(sieve7, k + 7);
			MarkOneSquare(sieve11, k + 11);
		}
	};
	MarkSquares(sieve1, 1); MarkSquares(sieve5,   5);
	MarkSquares(sieve7, 7); MarkSquares(sieve11, 11);
	tmr.LapTime(/*true, "squares"*/);

	// last loop - get primes
	auto CountOnePrime = [&](const tpPrime n)
	{ /*if (n < limit)*/ { numprimes++; AddPrime(n); } };
	for (tpPrime k = 0; k < svlen; k++)
	{
		uint8_t sv1 = sieve1[k], sv5 = sieve5[k], sv7 = sieve7[k], sv11 = sieve11[k];
		for (unsigned b = 0; b < 8; b++)
		{
			tpPrime n = 12 * (8 * k + b);
			if (sv1 & BIT_MASK[b]) CountOnePrime(n + 1);
			if (sv5 & BIT_MASK[b]) CountOnePrime(n + 5);
			if (sv7 & BIT_MASK[b]) CountOnePrime(n + 7);
			if (sv11& BIT_MASK[b]) CountOnePrime(n + 11);
		}
	}

	tmr.LapTime(/*true, "counting"*/);
	tmr.Stop(/*true, "squares & counting"*/);
	return numprimes;
}

